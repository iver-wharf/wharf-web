/**
 * Wharf main API
 * Wharf backend API that manages data storage for projects, builds, providers, etc.
 *
 * OpenAPI spec version: v5.1.1
 * Contact: wharf@iver.se
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { DeprecatedPaginatedBuilds } from '../model/deprecatedPaginatedBuilds';
import { DeprecatedProjectSearch } from '../model/deprecatedProjectSearch';
import { DeprecatedProjectUpdate } from '../model/deprecatedProjectUpdate';
import { ProblemResponse } from '../model/problemResponse';
import { RequestProject } from '../model/requestProject';
import { RequestProjectOverridesUpdate } from '../model/requestProjectOverridesUpdate';
import { RequestProjectUpdate } from '../model/requestProjectUpdate';
import { ResponseBuildReferenceWrapper } from '../model/responseBuildReferenceWrapper';
import { ResponsePaginatedProjects } from '../model/responsePaginatedProjects';
import { ResponseProject } from '../model/responseProject';
import { ResponseProjectOverrides } from '../model/responseProjectOverrides';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProjectService {

    protected basePath = 'https://localhost/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Creates project
     * Add project to database. Added in v0.1.10.
     * @param project Project to create
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProject(project: RequestProject, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseProject>;
    public createProject(project: RequestProject, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProject>>;
    public createProject(project: RequestProject, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProject>>;
    public createProject(project: RequestProject, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling createProject.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ResponseProject>(`${this.basePath}/project`,
            project,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete project with selected project ID
     * Added in v0.2.8.
     * @param projectId project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProject(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProject(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProject(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProject(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteProject.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete project&#39;s overrides with selected project ID
     * This will revert all overrides to the specified project. Equivalent to running &#x60;PUT /project/{projectId}/overrides&#x60; with all fields set to &#x60;null&#x60;. Added in v5.0.0.
     * @param projectId project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProjectOverrides(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProjectOverrides(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProjectOverrides(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProjectOverrides(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteProjectOverrides.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/override`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns project with selected project ID
     * Added in v0.1.8.
     * @param projectId project ID
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProject(projectId: number, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseProject>;
    public getProject(projectId: number, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProject>>;
    public getProject(projectId: number, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProject>>;
    public getProject(projectId: number, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProject.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponseProject>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all projects from database
     * List all projects, or a window of projects using the &#x60;limit&#x60; and &#x60;offset&#x60; query parameters. Allows optional filtering parameters. Verbatim filters will match on the entire string used to find exact matches, while the matching filters are meant for searches by humans where it tries to find soft matches and is therefore inaccurate by nature. Added in v5.0.0.
     * @param orderby Sorting orders. Takes the property name followed by either &#39;asc&#39; or &#39;desc&#39;. Can be specified multiple times for more granular sorting. Defaults to &#x60;?orderby&#x3D;projectId desc&#x60;
     * @param limit Number of results to return. No limiting is applied if empty (&#x60;?limit&#x3D;&#x60;) or non-positive (&#x60;?limit&#x3D;0&#x60;). Required if &#x60;offset&#x60; is used.
     * @param offset Skipped results, where 0 means from the start.
     * @param name Filter by verbatim project name.
     * @param groupName Filter by verbatim project group.
     * @param description Filter by verbatim description.
     * @param tokenId Filter by token ID. Zero (0) will search for null values.
     * @param providerId Filter by provider ID. Zero (0) will search for null values.
     * @param gitUrl Filter by verbatim Git URL.
     * @param nameMatch Filter by matching project name. Cannot be used with &#x60;name&#x60;.
     * @param groupNameMatch Filter by matching project group. Cannot be used with &#x60;groupName&#x60;.
     * @param descriptionMatch Filter by matching description. Cannot be used with &#x60;description&#x60;.
     * @param gitUrlMatch Filter by matching Git URL. Cannot be used with &#x60;gitUrl&#x60;.
     * @param match Filter by matching on any supported fields.
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectList(orderby?: Array<string>, limit?: number, offset?: number, name?: string, groupName?: string, description?: string, tokenId?: number, providerId?: number, gitUrl?: string, nameMatch?: string, groupNameMatch?: string, descriptionMatch?: string, gitUrlMatch?: string, match?: string, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponsePaginatedProjects>;
    public getProjectList(orderby?: Array<string>, limit?: number, offset?: number, name?: string, groupName?: string, description?: string, tokenId?: number, providerId?: number, gitUrl?: string, nameMatch?: string, groupNameMatch?: string, descriptionMatch?: string, gitUrlMatch?: string, match?: string, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePaginatedProjects>>;
    public getProjectList(orderby?: Array<string>, limit?: number, offset?: number, name?: string, groupName?: string, description?: string, tokenId?: number, providerId?: number, gitUrl?: string, nameMatch?: string, groupNameMatch?: string, descriptionMatch?: string, gitUrlMatch?: string, match?: string, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePaginatedProjects>>;
    public getProjectList(orderby?: Array<string>, limit?: number, offset?: number, name?: string, groupName?: string, description?: string, tokenId?: number, providerId?: number, gitUrl?: string, nameMatch?: string, groupNameMatch?: string, descriptionMatch?: string, gitUrlMatch?: string, match?: string, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (orderby) {
            orderby.forEach((element) => {
                queryParameters = queryParameters.append('orderby', <any>element);
            })
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (groupName !== undefined && groupName !== null) {
            queryParameters = queryParameters.set('groupName', <any>groupName);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (tokenId !== undefined && tokenId !== null) {
            queryParameters = queryParameters.set('tokenId', <any>tokenId);
        }
        if (providerId !== undefined && providerId !== null) {
            queryParameters = queryParameters.set('providerId', <any>providerId);
        }
        if (gitUrl !== undefined && gitUrl !== null) {
            queryParameters = queryParameters.set('gitUrl', <any>gitUrl);
        }
        if (nameMatch !== undefined && nameMatch !== null) {
            queryParameters = queryParameters.set('nameMatch', <any>nameMatch);
        }
        if (groupNameMatch !== undefined && groupNameMatch !== null) {
            queryParameters = queryParameters.set('groupNameMatch', <any>groupNameMatch);
        }
        if (descriptionMatch !== undefined && descriptionMatch !== null) {
            queryParameters = queryParameters.set('descriptionMatch', <any>descriptionMatch);
        }
        if (gitUrlMatch !== undefined && gitUrlMatch !== null) {
            queryParameters = queryParameters.set('gitUrlMatch', <any>gitUrlMatch);
        }
        if (match !== undefined && match !== null) {
            queryParameters = queryParameters.set('match', <any>match);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponsePaginatedProjects>(`${this.basePath}/project`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get project overrides
     * Get values for a project&#39;s overridable fields. Meant for manual overrides. Overridden field will take precedence when retreiving the project or in newly started builds, but will stay unaffected by regular project updates. Added in v5.0.0.
     * @param projectId project ID
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectOverrides(projectId: number, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseProjectOverrides>;
    public getProjectOverrides(projectId: number, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProjectOverrides>>;
    public getProjectOverrides(projectId: number, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProjectOverrides>>;
    public getProjectOverrides(projectId: number, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectOverrides.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponseProjectOverrides>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/override`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get slice of builds.
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /build?projectId&#x3D;123&#x60; instead. Added in v1.0.1.
     * @param projectId project ID
     * @param limit number of fetched branches
     * @param offset PK of last branch taken
     * @param orderby Sorting orders. Takes the property name followed by either &#39;asc&#39; or &#39;desc&#39;. Can be specified multiple times for more granular sorting. Defaults to &#x60;?orderby&#x3D;buildId desc&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldGetProjectBuildList(projectId: number, limit: string, offset: string, orderby?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<DeprecatedPaginatedBuilds>;
    public oldGetProjectBuildList(projectId: number, limit: string, offset: string, orderby?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeprecatedPaginatedBuilds>>;
    public oldGetProjectBuildList(projectId: number, limit: string, offset: string, orderby?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeprecatedPaginatedBuilds>>;
    public oldGetProjectBuildList(projectId: number, limit: string, offset: string, orderby?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling oldGetProjectBuildList.');
        }

        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling oldGetProjectBuildList.');
        }

        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling oldGetProjectBuildList.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (orderby) {
            orderby.forEach((element) => {
                queryParameters = queryParameters.append('orderby', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<DeprecatedPaginatedBuilds>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/builds`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all projects from database
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /project&#x60; instead. Added in v0.1.8.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldGetProjectList(observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseProject>>;
    public oldGetProjectList(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseProject>>>;
    public oldGetProjectList(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseProject>>>;
    public oldGetProjectList(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ResponseProject>>(`${this.basePath}/projects`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for projects from database
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /project&#x60; instead. Added in v0.5.5.
     * @param project Project search criteria
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldSearchProjectList(project?: DeprecatedProjectSearch, observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseProject>>;
    public oldSearchProjectList(project?: DeprecatedProjectSearch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseProject>>>;
    public oldSearchProjectList(project?: DeprecatedProjectSearch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseProject>>>;
    public oldSearchProjectList(project?: DeprecatedProjectSearch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<ResponseProject>>(`${this.basePath}/projects/search`,
            project,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Responsible for run stage environment for selected project
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;POST /project/{projectId}/build&#x60; instead. Added in v0.2.4.
     * @param projectId project ID
     * @param stage name of stage to run, or specify ALL to run everything
     * @param branch branch name, uses default branch if omitted
     * @param environment environment name
     * @param inputs user inputs
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldStartProjectBuild(projectId: number, stage: string, branch?: string, environment?: string, inputs?: string, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseBuildReferenceWrapper>;
    public oldStartProjectBuild(projectId: number, stage: string, branch?: string, environment?: string, inputs?: string, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBuildReferenceWrapper>>;
    public oldStartProjectBuild(projectId: number, stage: string, branch?: string, environment?: string, inputs?: string, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBuildReferenceWrapper>>;
    public oldStartProjectBuild(projectId: number, stage: string, branch?: string, environment?: string, inputs?: string, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling oldStartProjectBuild.');
        }

        if (stage === null || stage === undefined) {
            throw new Error('Required parameter stage was null or undefined when calling oldStartProjectBuild.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (branch !== undefined && branch !== null) {
            queryParameters = queryParameters.set('branch', <any>branch);
        }
        if (environment !== undefined && environment !== null) {
            queryParameters = queryParameters.set('environment', <any>environment);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ResponseBuildReferenceWrapper>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/${encodeURIComponent(String(stage))}/run`,
            inputs,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds project when not exists.
     * It finds project by ID or if ID is set to 0 it takes group name. First found project will be returned. If not found project will be added into database. It ignores branches array, build history and provider params. Deprecated since v5.0.0. Planned for removal in v6.0.0. Use POST /project to create, or PUT /project/{projectId} to update instead. Added in v0.2.13.
     * @param project project object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldUpdateProject(project?: DeprecatedProjectUpdate, observe?: 'body', reportProgress?: boolean): Observable<ResponseProject>;
    public oldUpdateProject(project?: DeprecatedProjectUpdate, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProject>>;
    public oldUpdateProject(project?: DeprecatedProjectUpdate, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProject>>;
    public oldUpdateProject(project?: DeprecatedProjectUpdate, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseProject>(`${this.basePath}/project`,
            project,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update project in database
     * Updates a project by replacing all of its fields. Added in v5.0.0.
     * @param projectId project ID
     * @param project New project values
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProject(projectId: number, project?: RequestProjectUpdate, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseProject>;
    public updateProject(projectId: number, project?: RequestProjectUpdate, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProject>>;
    public updateProject(projectId: number, project?: RequestProjectUpdate, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProject>>;
    public updateProject(projectId: number, project?: RequestProjectUpdate, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateProject.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseProject>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}`,
            project,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update project overrides in database
     * Updates a project by replacing all of its overridable fields. Meant for manual overrides. Overridden field will take precedence when retreiving the project or in newly started builds, but will stay unaffected by regular project updates. Added in v5.0.0.
     * @param projectId project ID
     * @param overrides New project overrides
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProjectOverrides(projectId: number, overrides?: RequestProjectOverridesUpdate, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseProjectOverrides>;
    public updateProjectOverrides(projectId: number, overrides?: RequestProjectOverridesUpdate, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProjectOverrides>>;
    public updateProjectOverrides(projectId: number, overrides?: RequestProjectOverridesUpdate, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProjectOverrides>>;
    public updateProjectOverrides(projectId: number, overrides?: RequestProjectOverridesUpdate, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateProjectOverrides.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseProjectOverrides>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/override`,
            overrides,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
