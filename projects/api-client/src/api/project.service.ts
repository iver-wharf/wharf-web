/**
 * Wharf main API
 * Wharf backend API that manages data storage for projects, builds, providers, etc.
 *
 * OpenAPI spec version: v5.0.0-rc.1
 * Contact: wharf@iver.se
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { DeprecatedProjectSearch } from '../model/deprecatedProjectSearch';
import { DeprecatedProjectUpdate } from '../model/deprecatedProjectUpdate';
import { ProblemResponse } from '../model/problemResponse';
import { RequestProject } from '../model/requestProject';
import { RequestProjectUpdate } from '../model/requestProjectUpdate';
import { ResponseBuildReferenceWrapper } from '../model/responseBuildReferenceWrapper';
import { ResponsePaginatedBuilds } from '../model/responsePaginatedBuilds';
import { ResponsePaginatedProjects } from '../model/responsePaginatedProjects';
import { ResponseProject } from '../model/responseProject';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProjectService {

    protected basePath = 'https://localhost/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Creates project
     * Add project to database.
     * @param project Project to create
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProject(project: RequestProject, observe?: 'body', reportProgress?: boolean): Observable<ResponseProject>;
    public createProject(project: RequestProject, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProject>>;
    public createProject(project: RequestProject, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProject>>;
    public createProject(project: RequestProject, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling createProject.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ResponseProject>(`${this.basePath}/project`,
            project,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete project with selected project ID
     * 
     * @param projectId project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProject(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProject(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProject(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProject(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteProject.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns project with selected project ID
     * 
     * @param projectId project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProject(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<ResponseProject>;
    public getProject(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProject>>;
    public getProject(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProject>>;
    public getProject(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProject.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponseProject>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all projects from database
     * List all projects, or a window of projects using the &#x60;limit&#x60; and &#x60;offset&#x60; query parameters. Allows optional filtering parameters. Verbatim filters will match on the entire string used to find exact matches, while the matching filters are meant for searches by humans where it tries to find soft matches and is therefore inaccurate by nature.
     * @param orderby Sorting orders. Takes the property name followed by either &#39;asc&#39; or &#39;desc&#39;. Can be specified multiple times for more granular sorting. Defaults to &#x60;?orderby&#x3D;projectId desc&#x60;
     * @param limit Number of results to return. No limiting is applied if empty (&#x60;?limit&#x3D;&#x60;) or non-positive (&#x60;?limit&#x3D;0&#x60;). Required if &#x60;offset&#x60; is used.
     * @param offset Skipped results, where 0 means from the start.
     * @param name Filter by verbatim project name.
     * @param groupName Filter by verbatim project group.
     * @param description Filter by verbatim description.
     * @param tokenId Filter by token ID. Zero (0) will search for null values.
     * @param providerId Filter by provider ID. Zero (0) will search for null values.
     * @param gitUrl Filter by verbatim Git URL.
     * @param nameMatch Filter by matching project name. Cannot be used with &#x60;name&#x60;.
     * @param groupNameMatch Filter by matching project group. Cannot be used with &#x60;groupName&#x60;.
     * @param descriptionMatch Filter by matching description. Cannot be used with &#x60;description&#x60;.
     * @param gitUrlMatch Filter by matching Git URL. Cannot be used with &#x60;gitUrl&#x60;.
     * @param match Filter by matching on any supported fields.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectList(orderby?: Array<string>, limit?: number, offset?: number, name?: string, groupName?: string, description?: string, tokenId?: number, providerId?: number, gitUrl?: string, nameMatch?: string, groupNameMatch?: string, descriptionMatch?: string, gitUrlMatch?: string, match?: string, observe?: 'body', reportProgress?: boolean): Observable<ResponsePaginatedProjects>;
    public getProjectList(orderby?: Array<string>, limit?: number, offset?: number, name?: string, groupName?: string, description?: string, tokenId?: number, providerId?: number, gitUrl?: string, nameMatch?: string, groupNameMatch?: string, descriptionMatch?: string, gitUrlMatch?: string, match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePaginatedProjects>>;
    public getProjectList(orderby?: Array<string>, limit?: number, offset?: number, name?: string, groupName?: string, description?: string, tokenId?: number, providerId?: number, gitUrl?: string, nameMatch?: string, groupNameMatch?: string, descriptionMatch?: string, gitUrlMatch?: string, match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePaginatedProjects>>;
    public getProjectList(orderby?: Array<string>, limit?: number, offset?: number, name?: string, groupName?: string, description?: string, tokenId?: number, providerId?: number, gitUrl?: string, nameMatch?: string, groupNameMatch?: string, descriptionMatch?: string, gitUrlMatch?: string, match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (orderby) {
            orderby.forEach((element) => {
                queryParameters = queryParameters.append('orderby', <any>element);
            })
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (groupName !== undefined && groupName !== null) {
            queryParameters = queryParameters.set('groupName', <any>groupName);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (tokenId !== undefined && tokenId !== null) {
            queryParameters = queryParameters.set('tokenId', <any>tokenId);
        }
        if (providerId !== undefined && providerId !== null) {
            queryParameters = queryParameters.set('providerId', <any>providerId);
        }
        if (gitUrl !== undefined && gitUrl !== null) {
            queryParameters = queryParameters.set('gitUrl', <any>gitUrl);
        }
        if (nameMatch !== undefined && nameMatch !== null) {
            queryParameters = queryParameters.set('nameMatch', <any>nameMatch);
        }
        if (groupNameMatch !== undefined && groupNameMatch !== null) {
            queryParameters = queryParameters.set('groupNameMatch', <any>groupNameMatch);
        }
        if (descriptionMatch !== undefined && descriptionMatch !== null) {
            queryParameters = queryParameters.set('descriptionMatch', <any>descriptionMatch);
        }
        if (gitUrlMatch !== undefined && gitUrlMatch !== null) {
            queryParameters = queryParameters.set('gitUrlMatch', <any>gitUrlMatch);
        }
        if (match !== undefined && match !== null) {
            queryParameters = queryParameters.set('match', <any>match);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponsePaginatedProjects>(`${this.basePath}/project`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get slice of builds.
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /build?projectId&#x3D;123&#x60; instead.
     * @param projectId project ID
     * @param limit number of fetched branches
     * @param offset PK of last branch taken
     * @param orderby Sorting orders. Takes the property name followed by either &#39;asc&#39; or &#39;desc&#39;. Can be specified multiple times for more granular sorting. Defaults to &#x60;?orderby&#x3D;buildId desc&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldGetProjectBuildList(projectId: number, limit: string, offset: string, orderby?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<ResponsePaginatedBuilds>;
    public oldGetProjectBuildList(projectId: number, limit: string, offset: string, orderby?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePaginatedBuilds>>;
    public oldGetProjectBuildList(projectId: number, limit: string, offset: string, orderby?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePaginatedBuilds>>;
    public oldGetProjectBuildList(projectId: number, limit: string, offset: string, orderby?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling oldGetProjectBuildList.');
        }

        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling oldGetProjectBuildList.');
        }

        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling oldGetProjectBuildList.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (orderby) {
            orderby.forEach((element) => {
                queryParameters = queryParameters.append('orderby', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponsePaginatedBuilds>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/builds`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all projects from database
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /project&#x60; instead.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldGetProjectList(observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseProject>>;
    public oldGetProjectList(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseProject>>>;
    public oldGetProjectList(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseProject>>>;
    public oldGetProjectList(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ResponseProject>>(`${this.basePath}/projects`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for projects from database
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /project&#x60; instead.
     * @param project Project search criteria
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldSearchProjectList(project?: DeprecatedProjectSearch, observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseProject>>;
    public oldSearchProjectList(project?: DeprecatedProjectSearch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseProject>>>;
    public oldSearchProjectList(project?: DeprecatedProjectSearch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseProject>>>;
    public oldSearchProjectList(project?: DeprecatedProjectSearch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<ResponseProject>>(`${this.basePath}/projects/search`,
            project,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds project when not exists.
     * It finds project by ID or if ID is set to 0 it takes group name. First found project will be returned. If not found project will be added into database. It ignores branches array, build history and provider params. Deprecated since v5.0.0. Planned for removal in v6.0.0. Use POST /project to create, or PUT /project/{projectId} to update instead.
     * @param project project object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldUpdateProject(project?: DeprecatedProjectUpdate, observe?: 'body', reportProgress?: boolean): Observable<ResponseProject>;
    public oldUpdateProject(project?: DeprecatedProjectUpdate, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProject>>;
    public oldUpdateProject(project?: DeprecatedProjectUpdate, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProject>>;
    public oldUpdateProject(project?: DeprecatedProjectUpdate, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseProject>(`${this.basePath}/project`,
            project,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Responsible for run stage environment for selected project
     * 
     * @param projectId project ID
     * @param stage name of stage to run, or specify ALL to run everything
     * @param branch branch name, uses default branch if omitted
     * @param environment environment name
     * @param inputs user inputs
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProjectBuild(projectId: number, stage: string, branch?: string, environment?: string, inputs?: string, observe?: 'body', reportProgress?: boolean): Observable<ResponseBuildReferenceWrapper>;
    public startProjectBuild(projectId: number, stage: string, branch?: string, environment?: string, inputs?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBuildReferenceWrapper>>;
    public startProjectBuild(projectId: number, stage: string, branch?: string, environment?: string, inputs?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBuildReferenceWrapper>>;
    public startProjectBuild(projectId: number, stage: string, branch?: string, environment?: string, inputs?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startProjectBuild.');
        }

        if (stage === null || stage === undefined) {
            throw new Error('Required parameter stage was null or undefined when calling startProjectBuild.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (branch !== undefined && branch !== null) {
            queryParameters = queryParameters.set('branch', <any>branch);
        }
        if (environment !== undefined && environment !== null) {
            queryParameters = queryParameters.set('environment', <any>environment);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ResponseBuildReferenceWrapper>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/${encodeURIComponent(String(stage))}/run`,
            inputs,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update project in database
     * Updates a project by replacing all of its fields.
     * @param projectId project ID
     * @param project New project values
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProject(projectId: number, project?: RequestProjectUpdate, observe?: 'body', reportProgress?: boolean): Observable<ResponseProject>;
    public updateProject(projectId: number, project?: RequestProjectUpdate, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProject>>;
    public updateProject(projectId: number, project?: RequestProjectUpdate, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProject>>;
    public updateProject(projectId: number, project?: RequestProjectUpdate, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateProject.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseProject>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}`,
            project,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
