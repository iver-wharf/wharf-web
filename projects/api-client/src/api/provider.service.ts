/**
 * Wharf main API
 * Wharf backend API that manages data storage for projects, builds, providers, etc.
 *
 * OpenAPI spec version: v5.0.0-rc.1
 * Contact: wharf@iver.se
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { DeprecatedProviderUpdate } from '../model/deprecatedProviderUpdate';
import { ProblemResponse } from '../model/problemResponse';
import { RequestProvider } from '../model/requestProvider';
import { RequestProviderSearch } from '../model/requestProviderSearch';
import { RequestProviderUpdate } from '../model/requestProviderUpdate';
import { ResponsePaginatedProviders } from '../model/responsePaginatedProviders';
import { ResponseProvider } from '../model/responseProvider';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProviderService {

    protected basePath = 'https://localhost/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add provider to database.
     * Add provider to database. Token in post object has to exists or should be empty. Token will has to be updated Provider ID during this operation.
     * @param provider Provider to create
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProvider(provider?: RequestProvider, observe?: 'body', reportProgress?: boolean): Observable<ResponseProvider>;
    public createProvider(provider?: RequestProvider, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProvider>>;
    public createProvider(provider?: RequestProvider, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProvider>>;
    public createProvider(provider?: RequestProvider, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ResponseProvider>(`${this.basePath}/provider`,
            provider,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns provider with selected provider ID
     * 
     * @param providerId Provider ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProvider(providerId: number, observe?: 'body', reportProgress?: boolean): Observable<ResponseProvider>;
    public getProvider(providerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProvider>>;
    public getProvider(providerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProvider>>;
    public getProvider(providerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling getProvider.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponseProvider>(`${this.basePath}/provider/${encodeURIComponent(String(providerId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get slice of providers.
     * List all providers, or a window of providers using the &#x60;limit&#x60; and &#x60;offset&#x60; query parameters. Allows optional filtering parameters. Verbatim filters will match on the entire string used to find exact matches, while the matching filters are meant for searches by humans where it tries to find soft matches and is therefore inaccurate by nature.
     * @param limit Number of results to return. No limiting is applied if empty (&#x60;?limit&#x3D;&#x60;) or non-positive (&#x60;?limit&#x3D;0&#x60;). Required if &#x60;offset&#x60; is used.
     * @param offset Skipped results, where 0 means from the start.
     * @param orderby Sorting orders. Takes the property name followed by either &#39;asc&#39; or &#39;desc&#39;. Can be specified multiple times for more granular sorting. Defaults to &#x60;?orderby&#x3D;providerId desc&#x60;
     * @param name Filter by verbatim provider name.
     * @param url Filter by verbatim provider URL.
     * @param nameMatch Filter by matching provider name. Cannot be used with &#x60;name&#x60;.
     * @param urlMatch Filter by matching provider URL. Cannot be used with &#x60;url&#x60;.
     * @param match Filter by matching on any supported fields.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProviderList(limit?: number, offset?: number, orderby?: Array<string>, name?: string, url?: string, nameMatch?: string, urlMatch?: string, match?: string, observe?: 'body', reportProgress?: boolean): Observable<ResponsePaginatedProviders>;
    public getProviderList(limit?: number, offset?: number, orderby?: Array<string>, name?: string, url?: string, nameMatch?: string, urlMatch?: string, match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePaginatedProviders>>;
    public getProviderList(limit?: number, offset?: number, orderby?: Array<string>, name?: string, url?: string, nameMatch?: string, urlMatch?: string, match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePaginatedProviders>>;
    public getProviderList(limit?: number, offset?: number, orderby?: Array<string>, name?: string, url?: string, nameMatch?: string, urlMatch?: string, match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (orderby) {
            orderby.forEach((element) => {
                queryParameters = queryParameters.append('orderby', <any>element);
            })
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (url !== undefined && url !== null) {
            queryParameters = queryParameters.set('url', <any>url);
        }
        if (nameMatch !== undefined && nameMatch !== null) {
            queryParameters = queryParameters.set('nameMatch', <any>nameMatch);
        }
        if (urlMatch !== undefined && urlMatch !== null) {
            queryParameters = queryParameters.set('urlMatch', <any>urlMatch);
        }
        if (match !== undefined && match !== null) {
            queryParameters = queryParameters.set('match', <any>match);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponsePaginatedProviders>(`${this.basePath}/provider`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns first 100 providers
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /provider&#x60; instead.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldGetProviderList(observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseProvider>>;
    public oldGetProviderList(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseProvider>>>;
    public oldGetProviderList(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseProvider>>>;
    public oldGetProviderList(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ResponseProvider>>(`${this.basePath}/providers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns arrays of providers that match to search criteria.
     * Returns arrays of providers that match to search criteria. It takes into consideration name, URL and token ID. Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /provider&#x60; instead.
     * @param provider provider object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldSearchProviderList(provider?: RequestProviderSearch, observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseProvider>>;
    public oldSearchProviderList(provider?: RequestProviderSearch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseProvider>>>;
    public oldSearchProviderList(provider?: RequestProviderSearch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseProvider>>>;
    public oldSearchProviderList(provider?: RequestProviderSearch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<ResponseProvider>>(`${this.basePath}/providers/search`,
            provider,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put provider in database.
     * Creates a new provider if a match is not found. Deprecated since v5.0.0. Planned for removal in v6.0.0. Use POST /provider to create, or PUT /provider/{providerId} to update instead.
     * @param provider provider object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldUpdateProvider(provider?: DeprecatedProviderUpdate, observe?: 'body', reportProgress?: boolean): Observable<ResponseProvider>;
    public oldUpdateProvider(provider?: DeprecatedProviderUpdate, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProvider>>;
    public oldUpdateProvider(provider?: DeprecatedProviderUpdate, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProvider>>;
    public oldUpdateProvider(provider?: DeprecatedProviderUpdate, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseProvider>(`${this.basePath}/provider`,
            provider,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update provider in database.
     * Updates a provider by replacing all of its fields.
     * @param providerId ID of provider to update
     * @param provider New provider values
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProvider(providerId: number, provider?: RequestProviderUpdate, observe?: 'body', reportProgress?: boolean): Observable<ResponseProvider>;
    public updateProvider(providerId: number, provider?: RequestProviderUpdate, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseProvider>>;
    public updateProvider(providerId: number, provider?: RequestProviderUpdate, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseProvider>>;
    public updateProvider(providerId: number, provider?: RequestProviderUpdate, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling updateProvider.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseProvider>(`${this.basePath}/provider/${encodeURIComponent(String(providerId))}`,
            provider,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
