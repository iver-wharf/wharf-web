/**
 * Wharf main API
 * Wharf backend API that manages data storage for projects, builds, providers, etc.
 *
 * OpenAPI spec version: v5.1.2
 * Contact: wharf@iver.se
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { DeprecatedToken } from '../model/deprecatedToken';
import { ProblemResponse } from '../model/problemResponse';
import { RequestToken } from '../model/requestToken';
import { RequestTokenSearch } from '../model/requestTokenSearch';
import { RequestTokenUpdate } from '../model/requestTokenUpdate';
import { ResponsePaginatedTokens } from '../model/responsePaginatedTokens';
import { ResponseToken } from '../model/responseToken';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class TokenService {

    protected basePath = 'https://localhost/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add token to database.
     * Add token to database. Provider in post object has to exists or should be empty. Added in v0.2.0.
     * @param token Token to create
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createToken(token?: RequestToken, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseToken>;
    public createToken(token?: RequestToken, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseToken>>;
    public createToken(token?: RequestToken, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseToken>>;
    public createToken(token?: RequestToken, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ResponseToken>(`${this.basePath}/token`,
            token,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns token with selected token ID
     * Added in v0.2.2.
     * @param tokenId Token ID
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getToken(tokenId: number, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseToken>;
    public getToken(tokenId: number, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseToken>>;
    public getToken(tokenId: number, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseToken>>;
    public getToken(tokenId: number, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling getToken.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponseToken>(`${this.basePath}/token/${encodeURIComponent(String(tokenId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get slice of tokens.
     * List all tokens, or a window of tokens using the &#x60;limit&#x60; and &#x60;offset&#x60; query parameters. Allows optional filtering parameters. Verbatim filters will match on the entire string used to find exact matches, while the matching filters are meant for searches by humans where it tries to find soft matches and is therefore inaccurate by nature. Added in v5.0.0.
     * @param limit Number of results to return. No limiting is applied if empty (&#x60;?limit&#x3D;&#x60;) or non-positive (&#x60;?limit&#x3D;0&#x60;). Required if &#x60;offset&#x60; is used.
     * @param offset Skipped results, where 0 means from the start.
     * @param orderby Sorting orders. Takes the property name followed by either &#39;asc&#39; or &#39;desc&#39;. Can be specified multiple times for more granular sorting. Defaults to &#x60;?orderby&#x3D;tokenId desc&#x60;
     * @param userName Filter by verbatim token user name.
     * @param userNameMatch Filter by matching token user name. Cannot be used with &#x60;userName&#x60;.
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTokenList(limit?: number, offset?: number, orderby?: Array<string>, userName?: string, userNameMatch?: string, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponsePaginatedTokens>;
    public getTokenList(limit?: number, offset?: number, orderby?: Array<string>, userName?: string, userNameMatch?: string, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePaginatedTokens>>;
    public getTokenList(limit?: number, offset?: number, orderby?: Array<string>, userName?: string, userNameMatch?: string, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePaginatedTokens>>;
    public getTokenList(limit?: number, offset?: number, orderby?: Array<string>, userName?: string, userNameMatch?: string, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (orderby) {
            orderby.forEach((element) => {
                queryParameters = queryParameters.append('orderby', <any>element);
            })
        }
        if (userName !== undefined && userName !== null) {
            queryParameters = queryParameters.set('userName', <any>userName);
        }
        if (userNameMatch !== undefined && userNameMatch !== null) {
            queryParameters = queryParameters.set('userNameMatch', <any>userNameMatch);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponsePaginatedTokens>(`${this.basePath}/token`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns first 100 tokens
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /token&#x60; instead. Added in v0.2.0.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldGetTokenList(observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseToken>>;
    public oldGetTokenList(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseToken>>>;
    public oldGetTokenList(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseToken>>>;
    public oldGetTokenList(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ResponseToken>>(`${this.basePath}/tokens`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns arrays of tokens that match to search criteria.
     * Returns arrays of tokens that match to search criteria. It takes into consideration only token string and user name. Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /token&#x60; instead. Added in v0.2.10.
     * @param token Token search criteria
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldSearchTokenList(token?: RequestTokenSearch, observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseToken>>;
    public oldSearchTokenList(token?: RequestTokenSearch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseToken>>>;
    public oldSearchTokenList(token?: RequestTokenSearch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseToken>>>;
    public oldSearchTokenList(token?: RequestTokenSearch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<ResponseToken>>(`${this.basePath}/tokens/search`,
            token,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put token in database.
     * Creates a new token if a match is not found. Deprecated since v5.0.0. Planned for removal in v6.0.0. Use POST /token to create, or PUT /token/{tokenId} to update instead. Added in v4.1.0.
     * @param token Token to add or update
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldUpdateToken(token?: DeprecatedToken, observe?: 'body', reportProgress?: boolean): Observable<ResponseToken>;
    public oldUpdateToken(token?: DeprecatedToken, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseToken>>;
    public oldUpdateToken(token?: DeprecatedToken, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseToken>>;
    public oldUpdateToken(token?: DeprecatedToken, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseToken>(`${this.basePath}/token`,
            token,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update token in database.
     * Updates a token by replacing all of its fields. Added in v5.0.0.
     * @param tokenId ID of token to update
     * @param token New token values
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateToken(tokenId: number, token?: RequestTokenUpdate, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseToken>;
    public updateToken(tokenId: number, token?: RequestTokenUpdate, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseToken>>;
    public updateToken(tokenId: number, token?: RequestTokenUpdate, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseToken>>;
    public updateToken(tokenId: number, token?: RequestTokenUpdate, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling updateToken.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ResponseToken>(`${this.basePath}/token/${encodeURIComponent(String(tokenId))}`,
            token,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
