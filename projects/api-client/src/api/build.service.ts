/**
 * Wharf main API
 * Wharf backend API that manages data storage for projects, builds, providers, etc.
 *
 * OpenAPI spec version: v5.1.2
 * Contact: wharf@iver.se
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ProblemResponse } from '../model/problemResponse';
import { RequestBuildInputs } from '../model/requestBuildInputs';
import { RequestBuildStatusUpdate } from '../model/requestBuildStatusUpdate';
import { RequestLogOrStatusUpdate } from '../model/requestLogOrStatusUpdate';
import { ResponseBuild } from '../model/responseBuild';
import { ResponseBuildReferenceWrapper } from '../model/responseBuildReferenceWrapper';
import { ResponseLog } from '../model/responseLog';
import { ResponsePaginatedBuilds } from '../model/responsePaginatedBuilds';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class BuildService {

    protected basePath = 'https://localhost/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Post a log to selected build
     * Added in v0.1.0.
     * @param buildId build id
     * @param data data
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createBuildLog(buildId: number, data: RequestLogOrStatusUpdate, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createBuildLog(buildId: number, data: RequestLogOrStatusUpdate, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createBuildLog(buildId: number, data: RequestLogOrStatusUpdate, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createBuildLog(buildId: number, data: RequestLogOrStatusUpdate, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (buildId === null || buildId === undefined) {
            throw new Error('Required parameter buildId was null or undefined when calling createBuildLog.');
        }

        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createBuildLog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/build/${encodeURIComponent(String(buildId))}/log`,
            data,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Finds build by build ID
     * Added in v0.3.5.
     * @param buildId build id
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBuild(buildId: number, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseBuild>;
    public getBuild(buildId: number, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBuild>>;
    public getBuild(buildId: number, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBuild>>;
    public getBuild(buildId: number, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (buildId === null || buildId === undefined) {
            throw new Error('Required parameter buildId was null or undefined when calling getBuild.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponseBuild>(`${this.basePath}/build/${encodeURIComponent(String(buildId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get slice of builds.
     * List all builds, or a window of builds using the &#x60;limit&#x60; and &#x60;offset&#x60; query parameters. Allows optional filtering parameters. Verbatim filters will match on the entire string used to find exact matches, while the matching filters are meant for searches by humans where it tries to find soft matches and is therefore inaccurate by nature. Added in v5.0.0.
     * @param limit Number of results to return. No limiting is applied if empty (&#x60;?limit&#x3D;&#x60;) or non-positive (&#x60;?limit&#x3D;0&#x60;). Required if &#x60;offset&#x60; is used.
     * @param offset Skipped results, where 0 means from the start.
     * @param orderby Sorting orders. Takes the property name followed by either &#39;asc&#39; or &#39;desc&#39;. Can be specified multiple times for more granular sorting. Defaults to &#x60;?orderby&#x3D;buildId desc&#x60;
     * @param projectId Filter by project ID.
     * @param scheduledAfter Filter by builds with scheduled date later than value.
     * @param scheduledBefore Filter by builds with scheduled date earlier than value.
     * @param finishedAfter Filter by builds with finished date later than value.
     * @param finishedBefore Filter by builds with finished date earlier than value.
     * @param environment Filter by verbatim build environment.
     * @param gitBranch Filter by verbatim build Git branch.
     * @param stage Filter by verbatim build stage.
     * @param workerId Filter by verbatim worker ID.
     * @param isInvalid Filter by build&#39;s valid/invalid state.
     * @param status Filter by build status name
     * @param statusId Filter by build status ID. Cannot be used with &#x60;status&#x60;.
     * @param environmentMatch Filter by matching build environment. Cannot be used with &#x60;environment&#x60;.
     * @param gitBranchMatch Filter by matching build Git branch. Cannot be used with &#x60;gitBranch&#x60;.
     * @param stageMatch Filter by matching build stage. Cannot be used with &#x60;stage&#x60;.
     * @param match Filter by matching on any supported fields.
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBuildList(limit?: number, offset?: number, orderby?: Array<string>, projectId?: number, scheduledAfter?: Date, scheduledBefore?: Date, finishedAfter?: Date, finishedBefore?: Date, environment?: string, gitBranch?: string, stage?: string, workerId?: string, isInvalid?: boolean, status?: Array<'Scheduling' | 'Running' | 'Completed' | 'Failed'>, statusId?: Array<number>, environmentMatch?: string, gitBranchMatch?: string, stageMatch?: string, match?: string, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponsePaginatedBuilds>;
    public getBuildList(limit?: number, offset?: number, orderby?: Array<string>, projectId?: number, scheduledAfter?: Date, scheduledBefore?: Date, finishedAfter?: Date, finishedBefore?: Date, environment?: string, gitBranch?: string, stage?: string, workerId?: string, isInvalid?: boolean, status?: Array<'Scheduling' | 'Running' | 'Completed' | 'Failed'>, statusId?: Array<number>, environmentMatch?: string, gitBranchMatch?: string, stageMatch?: string, match?: string, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePaginatedBuilds>>;
    public getBuildList(limit?: number, offset?: number, orderby?: Array<string>, projectId?: number, scheduledAfter?: Date, scheduledBefore?: Date, finishedAfter?: Date, finishedBefore?: Date, environment?: string, gitBranch?: string, stage?: string, workerId?: string, isInvalid?: boolean, status?: Array<'Scheduling' | 'Running' | 'Completed' | 'Failed'>, statusId?: Array<number>, environmentMatch?: string, gitBranchMatch?: string, stageMatch?: string, match?: string, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePaginatedBuilds>>;
    public getBuildList(limit?: number, offset?: number, orderby?: Array<string>, projectId?: number, scheduledAfter?: Date, scheduledBefore?: Date, finishedAfter?: Date, finishedBefore?: Date, environment?: string, gitBranch?: string, stage?: string, workerId?: string, isInvalid?: boolean, status?: Array<'Scheduling' | 'Running' | 'Completed' | 'Failed'>, statusId?: Array<number>, environmentMatch?: string, gitBranchMatch?: string, stageMatch?: string, match?: string, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (orderby) {
            orderby.forEach((element) => {
                queryParameters = queryParameters.append('orderby', <any>element);
            })
        }
        if (projectId !== undefined && projectId !== null) {
            queryParameters = queryParameters.set('projectId', <any>projectId);
        }
        if (scheduledAfter !== undefined && scheduledAfter !== null) {
            queryParameters = queryParameters.set('scheduledAfter', <any>scheduledAfter.toISOString());
        }
        if (scheduledBefore !== undefined && scheduledBefore !== null) {
            queryParameters = queryParameters.set('scheduledBefore', <any>scheduledBefore.toISOString());
        }
        if (finishedAfter !== undefined && finishedAfter !== null) {
            queryParameters = queryParameters.set('finishedAfter', <any>finishedAfter.toISOString());
        }
        if (finishedBefore !== undefined && finishedBefore !== null) {
            queryParameters = queryParameters.set('finishedBefore', <any>finishedBefore.toISOString());
        }
        if (environment !== undefined && environment !== null) {
            queryParameters = queryParameters.set('environment', <any>environment);
        }
        if (gitBranch !== undefined && gitBranch !== null) {
            queryParameters = queryParameters.set('gitBranch', <any>gitBranch);
        }
        if (stage !== undefined && stage !== null) {
            queryParameters = queryParameters.set('stage', <any>stage);
        }
        if (workerId !== undefined && workerId !== null) {
            queryParameters = queryParameters.set('workerId', <any>workerId);
        }
        if (isInvalid !== undefined && isInvalid !== null) {
            queryParameters = queryParameters.set('isInvalid', <any>isInvalid);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (statusId) {
            statusId.forEach((element) => {
                queryParameters = queryParameters.append('statusId', <any>element);
            })
        }
        if (environmentMatch !== undefined && environmentMatch !== null) {
            queryParameters = queryParameters.set('environmentMatch', <any>environmentMatch);
        }
        if (gitBranchMatch !== undefined && gitBranchMatch !== null) {
            queryParameters = queryParameters.set('gitBranchMatch', <any>gitBranchMatch);
        }
        if (stageMatch !== undefined && stageMatch !== null) {
            queryParameters = queryParameters.set('stageMatch', <any>stageMatch);
        }
        if (match !== undefined && match !== null) {
            queryParameters = queryParameters.set('match', <any>match);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResponsePaginatedBuilds>(`${this.basePath}/build`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Finds logs for build with selected build ID
     * Added in v0.3.8.
     * @param buildId build id
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBuildLogList(buildId: number, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<ResponseLog>>;
    public getBuildLogList(buildId: number, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResponseLog>>>;
    public getBuildLogList(buildId: number, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResponseLog>>>;
    public getBuildLogList(buildId: number, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (buildId === null || buildId === undefined) {
            throw new Error('Required parameter buildId was null or undefined when calling getBuildLogList.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ResponseLog>>(`${this.basePath}/build/${encodeURIComponent(String(buildId))}/log`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * NOT IMPLEMENTED
     * This endpoint was never implemented! Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;GET /build&#x60; instead. Added in v0.3.5.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldSearchBuildList(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public oldSearchBuildList(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public oldSearchBuildList(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public oldSearchBuildList(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/builds/search`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Partially update specific build
     * Deprecated since v5.0.0. Planned for removal in v6.0.0. Use &#x60;PUT /build/{buildId}/status&#x60; instead. Added in v2.0.1.
     * @param buildId build id
     * @param status Build status term
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public oldUpdateBuild(buildId: number, status: 'Scheduling' | 'Running' | 'Completed' | 'Failed', observe?: 'body', reportProgress?: boolean): Observable<ResponseBuild>;
    public oldUpdateBuild(buildId: number, status: 'Scheduling' | 'Running' | 'Completed' | 'Failed', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBuild>>;
    public oldUpdateBuild(buildId: number, status: 'Scheduling' | 'Running' | 'Completed' | 'Failed', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBuild>>;
    public oldUpdateBuild(buildId: number, status: 'Scheduling' | 'Running' | 'Completed' | 'Failed', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (buildId === null || buildId === undefined) {
            throw new Error('Required parameter buildId was null or undefined when calling oldUpdateBuild.');
        }

        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling oldUpdateBuild.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<ResponseBuild>(`${this.basePath}/build/${encodeURIComponent(String(buildId))}`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Start a new build for the given project, with optional build stage, build environment, or repo branch filters.
     * Added in v5.0.0.
     * @param projectId Project ID
     * @param stage Name of stage to run, or specify &#x60;ALL&#x60; to run all stages.
     * @param branch Branch name. Uses project&#39;s default branch if omitted
     * @param environment Environment name filter. If left empty it will run all stages without any environment filters.
     * @param engine Execution engine ID
     * @param inputs Input variable values. Map of variable names (as defined in the project&#39;s &#x60;.wharf-ci.yml&#x60; file) as keys paired with their string, boolean, or numeric value.
     * @param pretty Pretty indented JSON output
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProjectBuild(projectId: number, stage?: string, branch?: string, environment?: string, engine?: string, inputs?: RequestBuildInputs, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ResponseBuildReferenceWrapper>;
    public startProjectBuild(projectId: number, stage?: string, branch?: string, environment?: string, engine?: string, inputs?: RequestBuildInputs, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBuildReferenceWrapper>>;
    public startProjectBuild(projectId: number, stage?: string, branch?: string, environment?: string, engine?: string, inputs?: RequestBuildInputs, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBuildReferenceWrapper>>;
    public startProjectBuild(projectId: number, stage?: string, branch?: string, environment?: string, engine?: string, inputs?: RequestBuildInputs, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startProjectBuild.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (stage !== undefined && stage !== null) {
            queryParameters = queryParameters.set('stage', <any>stage);
        }
        if (branch !== undefined && branch !== null) {
            queryParameters = queryParameters.set('branch', <any>branch);
        }
        if (environment !== undefined && environment !== null) {
            queryParameters = queryParameters.set('environment', <any>environment);
        }
        if (engine !== undefined && engine !== null) {
            queryParameters = queryParameters.set('engine', <any>engine);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ResponseBuildReferenceWrapper>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/build`,
            inputs,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Opens stream listener
     * Added in v0.3.8.
     * @param buildId build id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public streamBuildLog(buildId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public streamBuildLog(buildId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public streamBuildLog(buildId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public streamBuildLog(buildId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (buildId === null || buildId === undefined) {
            throw new Error('Required parameter buildId was null or undefined when calling streamBuildLog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/x-json-stream'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/build/${encodeURIComponent(String(buildId))}/stream`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a build&#39;s status.
     * Added in v5.0.0.
     * @param buildId Build ID
     * @param data Status update
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateBuildStatus(buildId: number, data: RequestBuildStatusUpdate, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateBuildStatus(buildId: number, data: RequestBuildStatusUpdate, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateBuildStatus(buildId: number, data: RequestBuildStatusUpdate, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateBuildStatus(buildId: number, data: RequestBuildStatusUpdate, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (buildId === null || buildId === undefined) {
            throw new Error('Required parameter buildId was null or undefined when calling updateBuildStatus.');
        }

        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling updateBuildStatus.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/build/${encodeURIComponent(String(buildId))}/status`,
            data,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
